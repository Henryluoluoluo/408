#<center>王道

###第一章
####2.3.3
二、综合应用题

```
01.删除最小值的元素并返回被删元素的值，空出的位置由最后一个元素填充

bool delete(SeqList& L) {
    if(L.length == 0) return false;  //若没有元素返回错误信息

    int p = 0;  //假设第一个位置的元素是最小值
    for(int i = 1;i < L.lenght;i ++) 
        if(L.data[p] > L.data[i])  //当前位置小于假定最小值
            p = i;
    
    L.data[p] = L.data[L.length - 1];
    L.length --;

    return true;
}

```

```
02.将元素逆置

void reverse(SeqList& L) {
    if(L.length == 0) return ;

    for(int i = 0,j = L.length - 1;i < j;i ++,j --) 
        swap(L.data[i],L.data[j]);
    
    return ;
}
```

```
03.删除所有值为x的元素

###第一种方法
void delete(SeqList& L,ElemType x) {
    int p = 0;  //标记下一个可插入的位置

    for(int i = 0;i < L.length;i ++) {
        if(L.data[i] != x) 
            L.data[p ++] = L.data[i];
    }

    L.length = p;

    return ;
}

###第二种方法
void delete(SeqList& L,ElemType x) {
    int cnt = 0;  //标记删除x的个数

    for(int i = 0;i < L.length;i ++) {
        if(L.data[i] == x) cnt ++;
        else L.data[i - len] = L.data[i];
    }

    L.length -= cnt;

    return ;
}
```

```
04.有序顺序表删除s与t之间的所有元素
bool delete(SeqList& L,ElemType s,ElemType t) {
    if(L.length == 0 || s > t) return false;

    //首先找到第一个大于等于s的位置
    int l = 0;
    while(l < L.length && L.data[l] < s) l ++;

    //找到第一个大于t的位置
    int r = l;
    while(r < L.length && L.data[r] <= t) r ++;

    //将大于t的元素向左移动
    while(r < L.length) 
        L.data[l ++] = L.data[r ++];
    
    //更新L的长度
    L.length = l;

    return true;
}
```

```
05.删除介于s与t之间的所有元素
bool delete(SeqList& L,ElemType s,ElemType t) {
    if(L.length == 0 || s > t) return false;

    int len = 0;   //标记删除元素个数

    for(int i = 0;i < L.length;i ++) {
        if(L.data[i] >= s && L.data[i] <= t) len ++;
        else L.data[i - len] = L.data[i];
    }

    //更新长度
    L.length -= len;

    return true;
}
```

```
06.有序顺序表删除其重复元素
void unique(SeqList& L) {
    int p = 0;  //下一个要插入的位置

    for(int i = 0;i < L.length;i ++) {
        L.data[p ++] = L.data[i];   //子序列的第一个元素一定不是重复元素

        int j = i;
        while(j < L.length && L.data[j] == L.data[i]) j ++;
        i = j - 1;
    }

    L.length = p;

    return ;
}
```

```
07.合并有序顺序表
void merge(SeqList& a,SeqList& b,SeqList& c) {
     int i = 0,j = 0,k = 0;
     while(i < a.length && j < b.length) {
         if(a.data[i] <= b.data[j]) c.data[k ++] = a.data[i ++];
         else c.data[k ++] = b.data[j ++];
     }

     while(i < a.length) c.data[k ++] = a.data[i ++];
     while(j < b.length) c.data[k ++] = b.data[j ++];

     c.length = k;

     return ;
}
```

```
08.将前n个数和后m个数互换
void reverse(T a[],int l,int r) {
    for(int i = l,j = r;i < j;i ++,j --) 
        swap(a[i],a[j]);
}

void func(T a[],int n,int m) {
    reverse(a,0,n - 1);
    reverse(a,n,n + m - 1);
    reverse(a,0,n + m - 1);
}
```

```
09.递增线性表中找x,若找到与后继元素交换，若找不到插入使数组有序
void find(ElemType a[],int n,ElemType x) {
    int l = 0,r = n - 1;
    //查找第一个大于等于x的元素
    while(l < r) {
        int mid = l + r >> 1;
        if(a[mid] >= x) r = mid;
        else l = mid + 1;
    }

    //判断当前数是否等于x
    if(a[l] == x) swap(a[l],a[n - 1]);
    else {
        //将x插入
        for(int i = n;i > l;i --) {
            a[i] = a[i - 1];
        }
        a[l] = x;
    }
}
```

```
10.左移p个位置
void reverse(ElemType L[],int l,int r) {
    for(int i = l,j = r;i < j;i ++,j --) 
        swap(L[i],L[j]);
}

void shift(ElemType L[],int n,int p) {
    reverse(L,0,p - 1);
    reverse(L,p,n - 1);
    reverse(L,0,n - 1);
}
```

```
11.求中位数

int find(int a[],int b[],int n) {
    int la = 0,lb = 0,ra = n - 1,rb = n - 1;

    while(la != ra || lb != rb) {
        int ma = la + ra >> 1;
        int mb = lb + rb >> 1;
        if(a[ma] == b[mb]) return a[ma];
        else if(a[ma] < b[mb]) {
            if(la + ra % 2) {
                la = ma + 1;
                rb = mb;
            }
            else {
                la = ma;
                rb = mb;
            }
        }
        else {
            if(lb + rb % 2) {
                lb = mb + 1;
                ra = ma;
            }
            else {
                lb = mb;
                ra = ma;
            }
        }
    }

    return a[la] < b[lb] ? a[la] : b[lb];
}
```

```
12.求主元素
### 排序统计 时间复杂度O(nlogn)
int find(int a[],int n) {
    sort(a,a + n);
    int cnt = 0;

    for(int i = 0;i < n;i ++) {
        int j = i;
        while(j < n && a[i] == a[j]) j ++;

        cnt = max(cnt,j - i);
        if(cnt > n / 2) return a[i];

        i = j - 1;
    }

    return -1;
}

### 特殊方法
将主元素视为1，其余元素为-1，将所有元素相加一定大于0，因为加法满足交换律
所以最后值一定大于0
int find(int a[],int n) {
    int cnt = 0;
    int x = a[0];

    for(int i = 0;i < n;i ++) {
        if(a[i] == x) cnt ++;
        else {
            cnt --;
            if(cnt == 0) {
                x = a[i];
                cnt ++;
            }
        }
    }

    if(cnt) {
        cnt = 0;
        for(int i = 0;i < n;i ++) {
            if(a[i] == x) cnt ++;
        }
        if(cnt > n / 2) return x;
    }

    return -1;
}
```

```
13.最小未出现正整数
int find(int a[],int n) {
    bool *st = new st[n + 2];
    for(int i = 0;i < n;i ++) {
        if(a[i] > 0 && a[i] <= n) 
            st[a[i]] = true;
    }

    int x = 1;
    while(x <= n) {
        if(!st[x]) return x;
        x ++;
    }

    return x;
}
```

```
14.求三元组最小距离

//求绝对值
int abs(int x) {
    return x < 0 ? -x : x;
}

//求三元组的距离
int get_d(int i,int j,int k) {
    return abs(a[i] - b[j]) + abs(a[i] - c[k]) + abs(b[j] - c[k]);
}

bool min_p(int x,int y,int z) {
    if(x <= y && x <= z) return true;

    return false;
}

//求最小三元组
int min_d(int a[],int b[],int c[],int n,int m,int p) {
    int i = 0,j = 0,k = 0;
    int res = get_d(i,j,k);

    while(i < n && j < m && k < p) {
        res = min(res,get_d);
        if(min_p(a[i],b[j],c[k])) i ++;
        else if(min_p(b[j],a[i],c[k])) j ++;
        else k ++;
    }

    return res;
}

时间复杂度: O(max(|a|,|b|,|c|))
空间复杂度: O(1)

```

###2.3.7综合应用题
```
1.删除不带头节点的单链表中值为x的节点

void delete(LNode& s) {
    LNode *q = s -> next;

    if(q == null) {
        free(s);
        s = null;
    }
    else {
        s -> data = q -> data;
        s -> next = q -> next;
        free(q);
    }
}

void del(LinkNode &L,ElemType x) {
    if(L == null) return ;  //空表退出
    
    if(L -> data == x) {
        delete(L);
        del(L);
    }
    else del(L -> next);
}
```

```
2.
void del(LinkNode &L,ElemType x) {
    LNode *p = L -> next,*pre = L;
    
    while(p != null) {
        if(p -> data == x) {
            pre -> next = p -> next;
            free(p);
            p = pre -> next;
        }
        else {
            pre = p;
            p = p -> next;
        }
    }
}
```

```
3.反向输出带头节点的单链表的值

##将链表反向
void print(LinkList &L) {
    LinkNode *p = L -> next, *q;
    LinkNode *r = p;
    while(p != null) {
        q = p -> next;
        p -> next = L -> next;
        L -> next = p;
        p = q;
    }

    if(r != null) r -> next = null;

    p = L -> next;
    while(p != null) {
        print(p -> data);
        p = p -> next;
    }
    
    return ;
}

##利用系统栈
void dfs(LinkNode &s) {
    if(s == null) return ;
    else {
        dfs(s -> next); 

        print(s -> data);
    }

    return ;
}

dfs(L -> next);
```

```
4.删除最小值节点

void delete(LNode *s) {
    //删除点是最后一个点
    if(s -> next == null) {
        free(s);
        s = null;
    }
    LNode *p = s -> next;
    s -> data = p -> data;
    s -> next = p -> next;
    free(p);
}

void delete_min(LinkList &L) {
    LinkNode *min = L -> next;
    LinkNode *p = L -> next;

    while(p !=  null) {
        if(p -> data < min -> data) 
            min = p;
        p = p -> next;
    }

    if(min != null) delete(min);

    return ;
}
```


```
5.链表逆置
###头插法
void reverse(LinkList &L) {
    LinkNode *p = L -> next,*q;
    LinkNode *r = p;

    while(p != null) {
        q = p -> next;
        p -> next = L -> next;
        L -> next = p;
    }

    if(r != null) r -> next = null;
    return ;
}

###将指针逆置
void reverse(LinkList &L) {
    // 如果单链表只有一个元素或者没有元素直接返回
    if(L -> next == null) return ;
    LNode *pre = L -> next;
    if(p -> next == null) return ;
    LNode *p = pre -> next, *q;

    while(p != null) {
        q = p -> next;
        p -> next = pre;
        pre = p;
        p = q;
    }

    L -> next -> next = null;
    L -> next = pre;

    return ;
}
```

```
6.单链表排序

```

```
7. 删除带表头节点的单链表中介于给定值内的节点

void delete(LNode &s) {
    if(s == null) return ; //如果该节点是空结点，直接返回
    //如果该节点是最后一个节点，直接删除
    if(s -> next == null) {
        free(s);
        s = null;  
    }
    LNode *p = s -> next;
    s -> data = p -> data;
    s -> next = p -> next;
    free(p);
    
    return ;
}

void  delete_range(LinkList &L,E s, E t) {
    LNode *p = L -> next;

    while(p != null) {
        E x = p -> data;
        if(x > s && x < t) {
            delete(p);
        }
        else p = p -> next;
    }
}
```

```
8.找出两个单链表的公共结点
算法思想:
1.求出L1的长度,L2的长度
2.若长度不相等，让长度较短的链表指针先移动|L1 - L2| 长度
3.同时移动两个链表的指针，知道两个指针相等

int get_length(LinkList &L) {
    int len = 0;
    LNode *p = L -> next;

    while(p != null) {
        len ++;
        p = p -> next;
    }

    return len;
}

void move(LNode &p,int s) {
    while(s) {
        s --;
        p = p -> next;
    }
}

LNode* same(LinkList &L1,LinkList &L2) {
    int s1 = get_length(L1);
    int s2 = get_length(L2);
    LNode *p1 = L1 -> next;
    LNode *p2 = L2 -> next;

    if(s1 > s2) move(p1,s1 - s2);
    else move(p2,s2 - s1);

    while(p1 && p1 != p2) {
        p1 = p1 -> next;
        p2 = p2 -> next;
    }

    return p1;
}
```

```
9.以递增次序输出元素，并释放结点

//删除节点
void delete(LNode& s) {
    if(s == null) return;
    if(s -> next == null) {
        free(s);
        s = null;
    }
    LNode *p = s -> next;
    s -> data = p -> data;
    s -> next = p -> next;
    free(p);
}

void print_remove(LinkList &L) {
    LNode *p, *min;

    while(L -> next != null) {
        p = L -> next;
        min = p;
        //寻找最小节点
        while(p != null) {
            if(min -> data > p -> data) {
                min = p;
            }
            p = p -> next;
        }

        //将最小节点删除
        print(min -> data);
        delete(min);
    }
    return ;
}
```

```
10.将单链表A分解为单链表A和B，使A中为原表中序号为奇数的节点
   B表中为原表中为偶数的节点

void divide(LinkList& A,LinkList &B) {
    B = new LNode;
    LNode *r = B;
    LNode *p = A -> next,*pre = A,*q;
    int cnt = 1;

    while(p != null) {
        //如果该结点是偶数
        if(cnt % 2 == 0) {
            q = p -> next;
            r -> next = p;
            r = p;
            pre -> next = q;
            p = q;
        }
        else {
            pre = p;
            p = p -> next;
        }
        cnt ++;
    }
}

###均采用头插法

void divide(LinkList& A,LinkLIst &B) {
    B = new LNode;
    LNode *rb = B,*ra = A;
    LNode *p = A -> next, *q;
    int cnt = 1;

    while(p != null) {
        if(cnt % 2 == 0) {
            ra -> next = p;
            ra = p;
        }
        else {
            rb -> next = p;
            rb = p;
        }
        p = p -> next;
        cnt ++;
    }
    //最后一定要指向空
    ra -> next = null;
    rb -> next = null;

    return ;
}
```

```
11.将C拆成两个线性表，A采用尾插法,B采用头插法

void divide(LinkList &a,LinkList &b,LinkList &c) {
    int cnt =  1;
    LNode *p = c -> next;
    LNode *ra = b;
    LNode *q;
    a -> next = null;

    while(p != null) {
        // 奇数：尾插法
        if(cnt % 2) {
            ra -> next = p;
            ra = p;
            p = p -> next;
        }
        else {
            q = p -> next;
            p -> next = b -> next;
            b -> next = p;
            p = q;
        }
        cnt ++;
    }
    ra -> next = null;
}
```

```
12.单链表去重

void unique(LinkList &L) {
    LNode *p = L -> next;
    LNode *q,*t;

    while(p != null) {
        q = p -> next;
        while(q != null && q -> data == p -> data) {
            t = q -> next;
            free(q);
            q = t;
        }
        p -> next = q;
        p = q;
    }
}
```

```
13.将两个递增单链表合并为一个递减单链表
void merge(LinkList& a,LinkList& b) {
    //将较小元素头插
    LNode *p = a -> next;
    LNode *q = b -> next;
    LNode *t;
    a -> next = null
    
    while(p != null && q != null) {
        if(p -> data <= q -> data) {
            t = p -> next;
            p -> next = a -> next;
            a -> next = p;
            p = t;
        }
        else {
            t = q -> next;
            q -> next = a -> next;
            a -> next = q;
            q = t;
        }
    }

    while(p != null) {
        t = p -> next;
        p -> next = a -> next;
        a -> next = p;
        p = t;
    }

    while(q != null) {
        t = q -> next;
        q -> next = a -> next;
        a -> next = q;
        q = t;
    }

    return ;
}
```

```
14.两个递增的单链表中产生公共元素链表C

void unique(LinkList &c) {
    LNode *s = c -> next;
    LNode *t,*q;

    while(s != null) {
        t = s -> next;
        while(t != null && t -> data == s -> data) {
            q = t -> next;
            free(t);
            t = q;
        }
        s -> next = t;
        s = s -> next;
    }
}

LinkList* same(LinkList &a,LinkList &b) {
    //采用双指针算法
    //当p < q,p向后移动
    //当p > q,q向后移动
    //当p == q,p和q同时向后移动
    LNode *p = a -> next;
    LNode *q = b -> next;
    LinkList *c = new LinkList;
    c -> next = null;
    while(p != null && q != null) {
        if(p -> data > q -> data) 
            q = q -> next;
        else if(p -> data < q -> data) {
            p = p -> next;
        }
        else {
            LNode *s = new LNode;
            s -> data = p -> data;
            //头插法
            s -> next = c -> next;
            c -> next = s;
            p = p -> next;
            q = q -> next;
        }
    }

    unique(c);

    return c;
}
```

```
15.求两个递增的集合的交集
void union(LinkList& a,LinkList& b) {
    LNode *c = a;
    LNode *p = a -> next;
    LNode *q = b -> next;
    LNode *t;

    while(p != null && q != null) {
        if(p -> data == q -> data) {
            //将p所指向的元素接到c后面
            c -> next = p;
            c = p;
            p = p -> next;
            //将q元素删除
            t = q;
            q = q -> next;
            free(t);
        }
        else if(p -> data < q -> data) {
            t = p;
            p = p -> next;
            free(t);
        }
        else {
            t = q;
            q = q -> next;
            free(t);
        }
    }

    while(p != null) {
        t = p;
        p = p -> next;
        free(t);
    }

    while(q != null) {
        t = q;
        q = q -> next;
        free(t);
    }

    c -> next = null;

    return ;
}
```

```
16.连续子串判断
// BF算法 (有头节点)
bool is_substr(LinkList& a,LinkList& b) {
    LNode *p = a -> next;
    LNode *q = b -> next;
    LNode *pre = a -> next;

    while(p != null && q != null) {
        if(p -> data == q -> data) {
            p = p -> next;
            q = q -> next;
        }
        else {
            pre = pre -> next;
            p = pre;
            q = b -> next;
        }
    }
    //此处定义空串是任何串的子串
    if(q == null) return true;
    else return false;
}
```

```
17. 判断带头节点的循环双链表是否对称
bool systemetic(LinkList &a) {
    LNode *l = a -> next;
    LNode *r = a -> pre;
    //循环条件不要漏判，不然会死循环
    while(l != r && l -> next != r) {
        if(l -> data != r -> data) 
            return false;
        l = l -> next;
        r = r -> pre;
    }

    return true;
}
```

```
18.将两个循环单链表h1,h2合并，h2连接到h1后

//查找某一个循环单链表的最后一个元素
LNode* find(LinkList& a) {
    //只包含头节点
    //if(a -> next == a) return null;
    //LNode *s = a -> next;
    LNode *s = a;
    while(s -> next != a) s = s -> next;

    return s;
}

void merge(LinkList &h1,LinkList &h2) {
    //查找h1的最后一个结点
    LNode *r1 = find(h1),*r2 = find(h2);

    //h1的最后一个元素指向h2
    r1 -> next = h2;
    //h2的最后一个元素指向h1
    r2 -> next = h1;
}
```

```
19.依次访问循环单链表的最小元素并删除

//查找最小结点
void find(LinkList &L,LNode &minv,LNode &mpre) {
    minv = L -> next;
    LNode *p = L -> next,*pre = L;

    while(p != L) {
        if(p -> data < minv -> data) {
            minv = p;
            mpre = pre;
        }
        pre = p;
        p = p -> next;
    }
}

void visit(LinkList &L) {
    LNode *p = L -> next, *pre = L;
    LNode *minv = pre;
    while(L -> next != L) {
        LNode *minv, *mpre;
        find(L,minv,mpre);
        mpre -> next = minv -> next;
        print(minv -> data);
        free(minv);
    }

    free(L);
    return ;
}
```

```
20.访问值为x的结点，更新频度，并重排序
双链表取下和插入时要特判是不是最后一个结点
LNode* Locate(LinkList& L,ElemType x) {
    //首先查找值为x的结点
    LNode *p = L -> next;
    while(p != null && p -> data != x) 
        p = p -> next;
    if(p == null) return null;
    //将p取下
    if(p -> next != null)
        p -> next -> pre = p -> pre;
    p -> pre -> next = p -> next;
    
    //更新p的频度
    p -> fre ++;
    //查找比p频度高的点
    LNode *q = p -> pre;
    while(q != L && q -> fre <= p -> fre) 
        q = q -> pre;
    
    p -> pre = q;
    p -> next = q -> next; 
    if(q -> next != null) q -> next -> pre = p;
    q -> next = p;

    return p;
}
```


```
21.判断单链表是否有环
算法思路: 
1.设置两个指针，slow指针每次移动一个距离，fast指针每次移动
两个距离
2.先让两个指针相遇，相遇点用t标识
3.再让slow从头节点开始移动，fast从t开始移动，直到两个
指针相遇
4.返回相遇点

LNode* converge(LinkList &L) {
    LNode *slow = L, *fast = L;
    
    while(fast && slow != fast) {
        slow = slow -> next;
        fast = fast -> next;
        if(fast == null) return null;
        fast = fast -> next;
    }
    //标记相遇结点
    LNode *t = fast;

    slow = L, fast = t;

    while(slow != fast) {
        slow = slow -> next;
        fast = fast -> next;
    }

    return slow;
}

```